<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head><title>Эмулятор нормальных алгоритмов Маркова</title>


  
  <link rel="stylesheet" type="text/css" href="%D0%AD%D0%BC%D1%83%D0%BB%D1%8F%D1%82%D0%BE%D1%80%20%D0%9D%D0%9C%D0%90_files/main.css">
  <link rel="shortcut icon" href="">
  <meta http-equiv="content-type" content="text/html; charset=windows-1251">
<style>
.Script   { font-family:monotype corsiva,serif;font-size:120%;font-style:italic }
.Coursive { font-family:times new roman,serif;font-size:120%;font-style:italic }
.Serif    { font-family:times new roman,serif;font-size:120% }
.ef       { font-size:10px;}
</style></head><body style="background-color: white;">
<div class="body">

<div class="header">
<div style="float: right; font-size: 8pt; margin-left: 3em;">
</div>

</div>
<div class="page">

<p>
</p><h1><span style="color: black;">Э</span>мулятор нормальных алгоритмов Маркова</h1>

<div style="display: block; height: 5px; width: 5em;">
<div style="display: block; font-size: 1px; height: 5px; width: 100%; background-color: rgb(194, 218, 194);"></div>
</div>





<script language="javascript">
<!--

function HighLightCode ( Code, Line )
{
  var Area = document.getElementById ("ParsedCode");
  var Alpha, Betha, Arrow, Dummy;
  Dummy = "<table width=146 cellspacing=0>";
  for ( i = 0; i < Code.length; ++i )
  {
    var Rule = Code[i];
    var pos = Rule.indexOf ( "->" )
    if ( pos < 0 ) pos = Rule.indexOf ( "=>" );
    if ( 0 <= pos )
    {
      Alpha = Rule.substr ( 0, pos );
      Arrow = Rule.substr ( pos, 2 );
      if ( Arrow == "->" ) Arrow = "&#8594"; else Arrow = "&#8614;";
      Betha = Rule.substr ( pos + 2, Rule.length - pos - 2 );
    }
    Dummy += "<tr valign=top";
    if ( i == Line ) Dummy += " bgcolor=#e0f0e0";
    Dummy += "><td align=right width=25>" + (i + 1 ) + ".&nbsp;</td><td align=right>" + Alpha + "</td><td align=center style=\"font-face:times new roman,serif;\">" + Arrow + "</td><td align=left>" + Betha + "&nbsp;&nbsp;</td></tr>";
  }
  Dummy += "</table>";
  Area.innerHTML = Dummy;
}

function RunOnce ()
{
  var RulesMaxQty = 50;
  var Res = false;
  var Executed = 0;
  var Code = document.getElementById ("CodeArea").value.split (/\n/);
  var Word = document.getElementById ("Word").value;
  var Rules = new Array ();
  var TerminalRule;
  var pos;
  var alpha, betha;
  var c;

  R = 0;
  for ( i = 0; i < Code.length && i < RulesMaxQty; ++i )
  {
    var tmp = Code[i];
    var Rule = "";
    for ( j = 0; j < tmp.length; ++j )
    {
      c = tmp.substr(j,1);
      if ( c != " " && c != "\t" ) Rule += c;
    }
    if ( 0 < Rule.length )
    {
       if ( Rule.indexOf ( "->" ) < 0 && Rule.indexOf ( "=>" ) < 0 )
         document.getElementById ("ErrorMsg").innerHTML += ( i + 1 ) + ": пропущен знак правила.\n";
       else
       {
         Rules[R] = Rule;
         ++R;
       }
    }
    else
      document.getElementById ("ErrorMsg").innerHTML += ( i + 1 ) + ": пустая строка.\n";
  }

  i = 0;
  TotalRules = R <= 20 ? R : 20;
  TerminalRule = false;
  while ( Executed == 0 && i < TotalRules && !TerminalRule )
  {
    TerminalRule = false;
    Rule = Rules[i];
    if ( 0 <= ( pos = Rule.indexOf ( "->" ) ) )
    {
      alpha = Rule.substr ( 0, pos );
      betha = Rule.substr ( pos + 2, Rule.length - pos - 2 );
      if ( 0 <= Word.indexOf (alpha) )
      {
        document.getElementById ("Word").value = Word.replace ( alpha, betha );
        Executed = i + 1;
      }
    }
    else if ( 0 <= ( pos = Rule.indexOf ( "=>" ) ) )
    {
      alpha = Rule.substr ( 0, pos );
      betha = Rule.substr ( pos + 2, Rule.length - pos - 2 );
      if ( 0 <= Word.indexOf (alpha) )
      {
        document.getElementById ("Word").value = Word.replace ( alpha, betha );
        TerminalRule = true;
        Executed = i + 1;
      }
    }
    if ( Executed ) HighLightCode ( Rules, i );
    ++i;
  }
  return ( Executed != 0 && !TerminalRule ) ? Executed : 0;
}

function Run ()
{
  var MaxExecution   = 500;
  var ExecutionCount = 0;
  var Applicable     = true;

  document.getElementById ("ErrorMsg").innerHTML = "";
  while ( RunOnce () && ExecutionCount < MaxExecution ) { ++ExecutionCount; }
  if ( ExecutionCount == MaxExecution )
    document.getElementById ("ErrorMsg").innerHTML += "Превышено время выполнения.\n";
  else
    document.getElementById ("ErrorMsg").innerHTML += "Выполнение завершено.\n";
}

function Step ()
{
  var ErrorMSg = document.getElementById ("ErrorMsg");
  if ( r = RunOnce() ) ErrorMSg.innerHTML += "Правило " + r + " применено.\n";
  else ErrorMSg.innerHTML = "Ни одно правило не применено, либо выполнено терминальное правило.\n";
}

function LoadAlg ( Word, Alg )
{
  document.getElementById ("ErrorMsg").innerHTML = "Загружена запись алгоритма.\n";
  document.getElementById ("Word").value = Word;
  document.getElementById ("CodeArea").value = Alg;
  document.getElementById ("ParsedCode").innerHTML = "<table width=100%><tr><td> </td></tr></table>";
}

-->
</script>

<table>
<tbody><tr valign="top"><td>

<p>
Входное (выходное) слово:<br>
<input size="40" class="ef" id="Word" style="width: 300px; font-family: lucida console,courier;" type="text">
</p>

<p>
Правила:<br>
</p><table cellspacing="0"><tbody><tr valign="top"><td style="border: 1px solid ; width: 146px;">
<textarea cols="20" rows="20" class="ef" id="CodeArea" style="border: medium none ; width: 148px;"></textarea>
</td><td width="2"></td><td id="ParsedCode" style="border: 1px solid ; width: 146px;">
<table width="100%"><tbody><tr><td> </td></tr></tbody></table>
</td></tr></tbody></table>


<p>
<input class="ef" value="Шаг" onclick="Step()" type="button">
<input class="ef" value="Запуск" onclick="Run()" type="button">
</p>

<p>
<textarea rows="4" class="ef" id="ErrorMsg" readonly="readonly" style="width: 300px;"></textarea>
</p>

<p>
Максимальное количество обрабатываемых правил: 20.<br>
Максимальное количество циклов выполнения: 500.
</p>

</td><td width="20"></td><td>
<p>

</p><h3><span style="color: black;">К</span>раткие теоретические сведения</h3>

<div style="display: block; height: 3px; width: 3em;">
<div style="display: block; font-size: 1px; height: 3px; width: 100%; background-color: rgb(194, 218, 194);"></div>
</div>


<p>
Нормальные алгоритмы Маркова (далее&nbsp;— НАМ), введенные советским
математиком А.&nbsp;А.&nbsp;Марковым, представляют собой класс
алгоритмов, применимых к словам некоторого алфавита.
Каждый НАМ определяется указанием алфавита, в котором он действует, и
схемы НАМ.
Алфавитом НАМ может служить любой конечный алфавит <span class="Serif"><i>A</i></span>.
Формулой подстановки в алфавите <span class="Serif"><i>A</i></span> называется выражение типа <span class="Serif"><i>p</i> &#8594; <i>q</i></span> (простая подстановка, в эмуляторе обозначена как -&gt;) или <span class="Serif"><i>p</i> &#8614; <i>q</i></span> (заключительная подстановка, в эмуляторе обозначена как =&gt;), где <span class="Serif"><i>p</i></span> и <span class="Serif"><i>q</i></span>&nbsp;— некоторые слова в алфавите <span class="Serif"><i>A</i></span>, называемые, соответственно, левой и правой частями формулы подстановки.
Каждый НАМ в алфавите <span class="Serif"><i>A</i></span> имеет конечное число формул подстановки. Их записывают в виде списка, который называется схемой алгоритма.
</p><p>

Применение НАМ к некоторому слову <span class="Serif"><i>S</i></span> заключается в следующем.
В списке формул подстановки ищется первая из тех формул, в которой левая часть входит в <span class="Serif"><i>S</i></span>.
Находится 1-е вхождение левой части формулы в <span class="Serif"><i>S</i></span> и вместо этого вхождения подставляется правая часть формулы.
Получается новое слово <span class="Serif"><i>S</i>'</span>.
Cо словом <span class="Serif"><i>S</i>'</span> производятся те же действия и т.д.
</p><p>

Данный процесс обрывается в 2-х случаях:
</p><div style="margin-left: 3.2em; text-indent: -3.2em;">
&nbsp;<table style="margin: 0em; padding: 0em; display: inline; vertical-align: -17%;" cellpadding="0" cellspacing="0"><tbody><tr>
<td style="text-align: right; width: 2.4em;">•</td><td style="width: 0.2em;"></td></tr></tbody></table>
к очередному слову применена одна из заключительных формул  подстановки;
</div>
<div style="margin-left: 3.2em; text-indent: -3.2em;">
&nbsp;<table style="margin: 0em; padding: 0em; display: inline; vertical-align: -17%;" cellpadding="0" cellspacing="0"><tbody><tr>
<td style="text-align: right; width: 2.4em;">•</td><td style="width: 0.2em;"></td></tr></tbody></table>
в слово не входит  ни одна  из левых частей формул  подстановки.</div>

<p>

Получаемое последнее слово является результатом применения НАМ к исходному слову <span class="Serif"><i>S</i></span>.
</p><p>


</p><h3><span style="color: black;">П</span>римеры на составление нормальных алгоритмов Маркова</h3>

<div style="display: block; height: 3px; width: 3em;">
<div style="display: block; font-size: 1px; height: 3px; width: 100%; background-color: rgb(194, 218, 194);"></div>
</div>


<p>

<b>Пример 1.</b>
В произвольном слове, состоящем из букв <span class="Serif">{<i>a</i>,&nbsp;<i>b</i>,&nbsp;<i>c</i>}</span>, все подряд стоящие одинаковые буквы заменить одной буквой (например, слово «abbbcaa» преобразовать в «abca»).
Схема НАМ. имеет вид:
</p><p>

</p><table>
<tbody><tr><td align="right">1.</td><td align="right"><span class="Serif"><i>aa</i></span></td><td align="center"><span class="Serif"> &#8594; </span></td><td align="left"><span class="Serif"><i>a</i></span></td></tr>
<tr><td align="right">2.</td><td align="right"><span class="Serif"><i>bb</i></span></td><td align="center"><span class="Serif"> &#8594; </span></td><td align="left"><span class="Serif"><i>b</i></span></td></tr>
<tr><td align="right">3.</td><td align="right"><span class="Serif"><i>cc</i></span></td><td align="center"><span class="Serif"> &#8594; </span></td><td align="left"><span class="Serif"><i>c</i></span></td></tr>
</tbody></table>
(<a href="#" onclick="LoadAlg ('abbbcaa', 'aa->a\nbb->b\ncc->c');">загрузить в эмулятор</a>)<p>
</p><p>
Применение этой схемы с слову «abbbcaa» последовательно даст слова:
«abbbca», «abbca» и «abca», после чего выполнение НАМ завершится.
Для проверки данного алгоритма загрузите его текст в эмулятор.
</p><p>

<b>Пример 2.</b>
Удвоить слово, состоящее из одинаковых символов (для определенности&nbsp;— «x»).
Т.е. слово «x» надо преобразовать в «xx», слово «xx»&nbsp;— в «xxxx» и т.д.
</p><p>

Схема НАМ для этого примера намного сложнее, чем для примера 1.
Нельзя написать <span class="Serif"><i>x</i> &#8594; <i>xx</i></span>, т.к. в этом случае на каждом шаге НАМ к слову будет добавляться символ «x» и этот процесс будет бесконечным.
Необходимо контролировать удвоение каждого символа слова так, чтобы каждый символ удвоился только один раз.
Для это введём маркер, с помощью которого будем обеспечивать контекст применения удваивающего правила.
</p><p>

</p><table>
<tbody><tr><td align="right">1.</td><td align="right"><span class="Serif">*<i>x</i></span></td><td align="center"><span class="Serif"> &#8594; </span></td><td align="left"><span class="Serif"><i>xx</i>*</span></td></tr>
<tr><td align="right">2.</td><td align="right"><span class="Serif">*</span></td><td align="center"><span class="Serif"> &#8614; </span></td><td></td></tr>
<tr><td align="right">3.</td><td align="right"></td><td align="center"><span class="Serif"> &#8594; </span></td><td align="left"><span class="Serif">*</span></td></tr>
</tbody></table>
(<a href="#" onclick="LoadAlg ('xx','*x->xx*\n *=>\n  ->*');">загрузить в эмулятор</a>)<p>
</p><p>Последнее правило вводит «маркер» '*' (или «курсор»), который с
помощью первого правила «перескакивает» через текущий символ слова и
удваивает его.
Применение этой схемы, например, к слову «xx» последовательно даст
слова: (3) «*xx», (1) «xx*x», (1) «xxxx*», (2) «xxxx» (в скобках указан
номер применяемой формулы подстановки).
</p><p>

<b>Пример 3.</b>
Дано слово в алфавите <span class="Serif">{<i>a</i>,&nbsp;<i>b</i>,&nbsp;<i>c</i>}</span>.
Упорядочить буквы входного слова в лексикографическом порядке </p>(<a href="#" onclick="LoadAlg ('cbabca','ba->ab\nca->ac\ncb->bc');">загрузить в эмулятор</a>).<p>
</p><p>

</p><p>

</p></td></tr>
</tbody></table>
<p>
</p></div>
<div class="footer">
</div>
</body></html>